// Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

package oci

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/terraform-exec/tfexec"

	oci_dns "github.com/oracle/oci-go-sdk/v30/dns"

	"github.com/hashicorp/hcl2/hclwrite"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"

	oci_core "github.com/oracle/oci-go-sdk/v30/core"
	oci_identity "github.com/oracle/oci-go-sdk/v30/identity"
	oci_load_balancer "github.com/oracle/oci-go-sdk/v30/loadbalancer"
)

type TerraformResourceHints struct {
	// Information about this resource
	resourceClass        string // The name of the resource class (e.g. oci_core_vcn)
	resourceAbbreviation string // An abbreviated version of the resource class used for generating shorter resource names (e.g. vcn)

	// Hints to help with discovering this resource using data sources
	datasourceClass              string                             // The name of the data source class to use for discovering resources (e.g. oci_core_vcns)
	datasourceItemsAttr          string                             // The attribute with the data source that contains the discovered resources returned by the data source (e.g. virtual_networks)
	isDatasourceCollection       bool                               // True if list datasource is modeled as a collection with `items` field under datasourceItemsAttr
	requireResourceRefresh       bool                               // Whether to use the resource to fill in missing information from datasource (e.g. when datasources only return summary information)
	discoverableLifecycleStates  []string                           // List of lifecycle states that should be discovered. If empty, then all lifecycle states are discoverable.
	processDiscoveredResourcesFn ProcessOCIResourcesFunc            // Custom function for processing resources discovered by the data source
	alwaysExportable             bool                               // Some resources always need to be exportable, regardless of whether they are being targeted for export
	getIdFn                      func(*OCIResource) (string, error) // If the resource has no OCID generated by services, then implement this to generate one from the OCIResource. Typically used for composite IDs.

	// Override function for discovering resources. To be used when there is no datasource implementation to help with discovery.
	findResourcesOverrideFn func(*resourceDiscoveryContext, *TerraformResourceAssociation, *OCIResource, *TerraformResourceGraph) ([]*OCIResource, error)

	// Hints to help with generating HCL representation from this resource
	getHCLStringOverrideFn func(*strings.Builder, *OCIResource, map[string]string) error // Custom function for generating HCL syntax for the resource

	// Hints for adding default value to HCL representation for attributes not found in resource discovery
	defaultValuesForMissingAttributes map[string]interface{}

	// Hints for adding resource attributes to `ignore_changes` in HCL representation
	// This is added to avoid plan failure/diff for attributes that service does not return in read response
	// The attributes references are interpolated in case of nested attributes
	ignorableRequiredMissingAttributes map[string]bool
}

func (h *TerraformResourceHints) DiscoversWithSingularDatasource() bool {
	return h.datasourceItemsAttr == ""
}

type TerraformResourceAssociation struct {
	*TerraformResourceHints
	datasourceQueryParams map[string]string // Mapping of data source inputs and the source attribute from a parent resource
}

// Wrapper around string value to differentiate strings from interpolations
// Differentiation needed to write oci_resource.resource_name vs "oci_resource.resource_name" for v0.12
type InterpolationString struct {
	resourceReference string
	interpolation     string
	value             string
}

type ResourceDiscoveryError struct {
	resourceType   string
	parentResource string
	error          error
	resourceGraph  *TerraformResourceGraph
}

type ErrorList = []*ResourceDiscoveryError

type resourceDiscoveryContext struct {
	terraform           *tfexec.Terraform
	clients             *OracleClients
	expectedResourceIds map[string]bool
	tenancyOcid         string
	discoveredResources []*OCIResource
	summaryStatements   []string
	*ExportCommandArgs
	errorList                    ErrorList
	missingAttributesPerResource map[string][]string
	isImportError                bool // flag indicates if there was an import failure and if reference map needs to be updated
}

// Resource discovery Exit status
type Status int

const (
	// Exit statuses
	StatusSuccess Status = iota
	StatusFail
	StatusPartialSuccess

	// Tags to filter resources
	OracleTagsCreatedBy           = "Oracle-Tags.CreatedBy"
	OkeTagValue                   = "oke"
	ResourceCreatedByInstancePool = "oci:compute:instancepool"
)

func (ctx *resourceDiscoveryContext) postValidate() error {
	// Check that all expected resource IDs were found, if any were given
	missingResourceIds := []string{}
	for resourceId, found := range ctx.expectedResourceIds {
		if !found {
			missingResourceIds = append(missingResourceIds, resourceId)
		}
	}

	if len(missingResourceIds) > 0 {
		ctx.summaryStatements = append(ctx.summaryStatements, "")
		ctx.summaryStatements = append(ctx.summaryStatements, "Warning: The following resource IDs were not found.")
		for _, resourceId := range missingResourceIds {
			ctx.summaryStatements = append(ctx.summaryStatements, fmt.Sprintf("- %s", resourceId))
		}
		return fmt.Errorf("[ERROR] one or more expected resource ids were not found")
	}
	return nil
}

func (ctx *resourceDiscoveryContext) printSummary() {

	ctx.summaryStatements = append(ctx.summaryStatements, "=== COMPLETED ===")

	for _, statement := range ctx.summaryStatements {
		Logln(green(statement))
	}
}

func (ctx *resourceDiscoveryContext) printErrors() {
	Logln(yellow("\n\n[WARN] Resource discovery finished with errors listed below:\n"))
	for _, resourceDiscoveryError := range ctx.errorList {
		if resourceDiscoveryError.parentResource == "export" {
			Logln(yellow(fmt.Sprintf("Error discovering `%s` resources: %s", resourceDiscoveryError.resourceType, resourceDiscoveryError.error.Error())))

		} else {
			Logln(yellow(fmt.Sprintf("Error discovering `%s` resources for %s: %s", resourceDiscoveryError.resourceType, resourceDiscoveryError.parentResource, resourceDiscoveryError.error.Error())))
		}
		/* log child resources if exist and were not discovered because of error in parent resource discovery*/
		if resourceDiscoveryError.resourceGraph != nil {
			var notFoundChildren []string
			getNotFoundChildren(resourceDiscoveryError.resourceType, resourceDiscoveryError.resourceGraph, &notFoundChildren)
			if len(notFoundChildren) > 0 {
				Logln(yellow(fmt.Sprintf("\tFollowing child resources were also not discovered due to parent error: %v", strings.Join(notFoundChildren, ", "))))
			}
		}
	}
}

func getNotFoundChildren(parent string, resourceGraph *TerraformResourceGraph, children *[]string) {
	childResources, exists := (*resourceGraph)[parent]
	if exists {
		for _, child := range childResources {
			*children = append(*children, child.resourceClass)
			// Avoid recursion if a resource can be nested within itself e.g. compartments
			if child.resourceClass != parent {
				getNotFoundChildren(child.resourceClass, resourceGraph, children)
			}
		}
	}
}

func createResourceDiscoveryContext(clients *OracleClients, args *ExportCommandArgs, tenancyOcid string) (*resourceDiscoveryContext, error) {
	result := &resourceDiscoveryContext{
		clients:             clients,
		ExportCommandArgs:   args,
		tenancyOcid:         tenancyOcid,
		discoveredResources: []*OCIResource{},
		summaryStatements:   []string{},
		errorList:           ErrorList{},
	}
	result.expectedResourceIds = convertStringSliceToSet(args.IDs, true)

	// validate terraform version and initialize terraform for import - only required if generating state file
	if args.GenerateState {
		if tf, err := createTerraformStruct(args); err != nil {
			return result, err
		} else {
			result.terraform = tf
		}
	}
	return result, nil
}

type resourceDiscoveryStep interface {
	discover() error
	getOmittedResources() []*OCIResource
	writeTmpConfigurationForImport() error
	writeConfiguration() error
}

type resourceDiscoveryBaseStep struct {
	ctx                 *resourceDiscoveryContext
	name                string
	discoveredResources []*OCIResource
	omittedResources    []*OCIResource
}

// writeTmpConfigurationForImport writes temporary configuration to run terraform import on the discovered resources
// It only writes the resource block and skips the resource fields
// The configuration will be discarded and written again after import is completed for all resources
func (r *resourceDiscoveryBaseStep) writeTmpConfigurationForImport() error {
	Debugln("writing temp config files for import")

	configOutputFile := fmt.Sprintf("%s%s%s.tf", *r.ctx.OutputDir, string(os.PathSeparator), r.name)
	tmpConfigOutputFile := fmt.Sprintf("%s%s%s.tf.tmp", *r.ctx.OutputDir, string(os.PathSeparator), r.name)

	file, err := os.OpenFile(tmpConfigOutputFile, os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		return err
	}

	// Build the HCL config
	builder := &strings.Builder{}
	builder.WriteString("## This is tmp config to run import for resources\n\n")
	for _, resource := range r.discoveredResources {
		builder.WriteString(fmt.Sprintf("resource %s %s {}\n\n", resource.terraformClass, resource.terraformName))
		r.ctx.discoveredResources = append(r.ctx.discoveredResources, resource)
	}

	_, err = file.WriteString(string(builder.String()))
	if err != nil {
		_ = file.Close()
		return err
	}

	if fErr := file.Close(); fErr != nil {
		return fErr
	}

	if err := os.Rename(tmpConfigOutputFile, configOutputFile); err != nil {
		return err
	}
	return nil
}

func (r *resourceDiscoveryBaseStep) writeConfiguration() error {
	configOutputFile := fmt.Sprintf("%s%s%s.tf", *r.ctx.OutputDir, string(os.PathSeparator), r.name)
	tmpConfigOutputFile := fmt.Sprintf("%s%s%s.tf.tmp", *r.ctx.OutputDir, string(os.PathSeparator), r.name)

	file, err := os.OpenFile(tmpConfigOutputFile, os.O_CREATE|os.O_RDWR, 0666)
	if err != nil {
		return err
	}

	// Build the HCL config
	// Note that we still build a TF file even if no resources were discovered for this TF file.
	// A user may run this command multiple times and may see stale resources if we don't overwrite the file with
	// an empty one.
	builder := &strings.Builder{}
	builder.WriteString("## This configuration was generated by terraform-provider-oci\n\n")

	exportedResourceCount := 0
	for _, resource := range r.discoveredResources {

		// Skip writing the config for resources for which import command failed
		if !resource.isErrorResource {
			Logf("[INFO] ===> Generating resource '%s'", resource.getTerraformReference())
			if err := resource.getHCLString(builder, referenceMap); err != nil {
				_ = file.Close()
				return err
			}

			if resource.terraformTypeInfo != nil && len(resource.terraformTypeInfo.ignorableRequiredMissingAttributes) > 0 {
				attributes := make([]string, 0, len(resource.terraformTypeInfo.ignorableRequiredMissingAttributes))
				for attribute := range resource.terraformTypeInfo.ignorableRequiredMissingAttributes {
					attributes = append(attributes, attribute)
				}
				if r.ctx.missingAttributesPerResource == nil {
					r.ctx.missingAttributesPerResource = make(map[string][]string)
				}
				r.ctx.missingAttributesPerResource[resource.getTerraformReference()] = attributes
			}

			r.ctx.discoveredResources = append(r.ctx.discoveredResources, resource)
			exportedResourceCount++
		} else {
			// remove missing attributes info if present for a failed resource
			if _, ok := r.ctx.missingAttributesPerResource[resource.getTerraformReference()]; ok {
				delete(r.ctx.missingAttributesPerResource, resource.getTerraformReference())
			}
		}
	}

	// Format the HCL config
	formattedString := hclwrite.Format([]byte(builder.String()))

	_, err = file.WriteString(string(formattedString))
	if err != nil {
		_ = file.Close()
		return err
	}

	if fErr := file.Close(); fErr != nil {
		return fErr
	}

	if err := os.Rename(tmpConfigOutputFile, configOutputFile); err != nil {
		return err
	}

	r.ctx.summaryStatements = append(r.ctx.summaryStatements, fmt.Sprintf("Found %d '%s' resources. Generated under '%s'.", exportedResourceCount, r.name, configOutputFile))
	return nil
}

func (r *resourceDiscoveryBaseStep) getOmittedResources() []*OCIResource {
	return r.omittedResources
}

type resourceDiscoveryWithGraph struct {
	resourceDiscoveryBaseStep
	root          *OCIResource
	resourceGraph TerraformResourceGraph
}

func (r *resourceDiscoveryWithGraph) discover() error {
	var err error
	var ociResources []*OCIResource
	ociResources, err = findResources(r.ctx, r.root, r.resourceGraph)
	if err != nil {
		return err
	}

	// Filter out omitted resources from export
	r.discoveredResources = []*OCIResource{}
	r.omittedResources = []*OCIResource{}
	for _, resource := range ociResources {
		if !resource.omitFromExport {
			referenceMap[resource.id] = resource.getHclReferenceIdString()
			r.discoveredResources = append(r.discoveredResources, resource)
		} else {
			r.omittedResources = append(r.omittedResources, resource)
		}
	}
	return nil
}

type resourceDiscoveryWithIds struct {
	resourceDiscoveryBaseStep
	exportIds map[string]string // map of IDs and their respective resource types
}

type TerraformResourceGraph map[string][]TerraformResourceAssociation

type ProcessOCIResourcesFunc func(*OracleClients, []*OCIResource) ([]*OCIResource, error)

func init() {
	// TODO: The following changes to resource hints are deviations from what can currently be handled by the core resource discovery/generation logic
	// We should strive to eliminate these deviations by either improving the core logic or code generator

	exportBlockchainOsnHints.getIdFn = getBlockchainOsnId
	exportBlockchainPeerHints.getIdFn = getBlockchainPeerId

	// Custom overrides for generating composite Load Balancer IDs within the resource discovery framework
	exportLoadBalancerBackendHints.processDiscoveredResourcesFn = processLoadBalancerBackends
	exportLoadBalancerBackendSetHints.processDiscoveredResourcesFn = processLoadBalancerBackendSets
	exportLoadBalancerCertificateHints.processDiscoveredResourcesFn = processLoadBalancerCertificates
	exportLoadBalancerHostnameHints.processDiscoveredResourcesFn = processLoadBalancerHostnames
	exportLoadBalancerListenerHints.findResourcesOverrideFn = findLoadBalancerListeners
	exportLoadBalancerPathRouteSetHints.processDiscoveredResourcesFn = processLoadBalancerPathRouteSets
	exportLoadBalancerRuleSetHints.processDiscoveredResourcesFn = processLoadBalancerRuleSets

	exportCoreBootVolumeHints.processDiscoveredResourcesFn = filterSourcedBootVolumes
	exportCoreCrossConnectGroupHints.discoverableLifecycleStates = append(exportCoreCrossConnectGroupHints.discoverableLifecycleStates, string(oci_core.CrossConnectGroupLifecycleStateInactive))
	exportCoreDhcpOptionsHints.processDiscoveredResourcesFn = processDefaultDhcpOptions
	exportCoreImageHints.processDiscoveredResourcesFn = filterCustomImages

	exportCoreInstanceHints.discoverableLifecycleStates = append(exportCoreInstanceHints.discoverableLifecycleStates, string(oci_core.InstanceLifecycleStateStopped))
	exportCoreInstanceHints.processDiscoveredResourcesFn = processInstances
	exportCorePrivateIpHints.processDiscoveredResourcesFn = processPrivateIps
	exportCoreInstanceHints.requireResourceRefresh = true
	exportCoreNetworkSecurityGroupSecurityRuleHints.datasourceClass = "oci_core_network_security_group_security_rules"
	exportCoreNetworkSecurityGroupSecurityRuleHints.datasourceItemsAttr = "security_rules"
	exportCoreNetworkSecurityGroupSecurityRuleHints.getIdFn = getCoreNetworkSecurityGroupSecurityRuleId
	exportCoreNetworkSecurityGroupSecurityRuleHints.processDiscoveredResourcesFn = processNetworkSecurityGroupRules
	exportCoreRouteTableHints.processDiscoveredResourcesFn = processDefaultRouteTables
	exportCoreSecurityListHints.processDiscoveredResourcesFn = processDefaultSecurityLists
	exportCoreVnicAttachmentHints.requireResourceRefresh = true
	exportCoreVnicAttachmentHints.processDiscoveredResourcesFn = filterSecondaryVnicAttachments
	exportCoreVolumeGroupHints.processDiscoveredResourcesFn = processVolumeGroups

	exportDatabaseAutonomousContainerDatabaseHints.requireResourceRefresh = true
	exportDatabaseAutonomousDatabaseHints.requireResourceRefresh = true
	exportDatabaseAutonomousDatabaseHints.processDiscoveredResourcesFn = processAutonomousDatabaseSource

	exportDatabaseAutonomousExadataInfrastructureHints.requireResourceRefresh = true

	exportDatabaseDbSystemHints.requireResourceRefresh = true
	exportDatabaseDbSystemHints.processDiscoveredResourcesFn = processDbSystems

	exportDatabaseDbHomeHints.processDiscoveredResourcesFn = filterPrimaryDbHomes
	exportDatabaseDbHomeHints.requireResourceRefresh = true

	exportDatabaseDatabaseHints.requireResourceRefresh = true
	exportDatabaseDatabaseHints.processDiscoveredResourcesFn = filterPrimaryDatabases

	exportDatabaseDatabaseHints.defaultValuesForMissingAttributes = map[string]interface{}{
		"source": "NONE",
	}
	exportDatabaseDatabaseHints.processDiscoveredResourcesFn = processDatabases

	exportDatabaseVmClusterNetworkHints.getIdFn = getDatabaseVmClusterNetworkId

	exportDatascienceModelHints.defaultValuesForMissingAttributes = map[string]interface{}{
		"artifact_content_length": "0",
	}
	exportDatascienceModelProvenanceHints.getIdFn = getModelProvenanceId

	exportIdentityAvailabilityDomainHints.resourceAbbreviation = "ad"
	exportIdentityAvailabilityDomainHints.alwaysExportable = true
	exportIdentityAvailabilityDomainHints.processDiscoveredResourcesFn = processAvailabilityDomains
	exportIdentityAvailabilityDomainHints.getHCLStringOverrideFn = getAvailabilityDomainHCLDatasource
	exportIdentityAuthenticationPolicyHints.processDiscoveredResourcesFn = processIdentityAuthenticationPolicies
	exportIdentityTagHints.findResourcesOverrideFn = findIdentityTags
	exportIdentityTagHints.processDiscoveredResourcesFn = processTagDefinitions

	exportLoggingLogHints.getIdFn = getLogId

	exportObjectStorageNamespaceHints.processDiscoveredResourcesFn = processObjectStorageNamespace
	exportObjectStorageNamespaceHints.getHCLStringOverrideFn = getObjectStorageNamespaceHCLDatasource
	exportObjectStorageNamespaceHints.alwaysExportable = true
	exportOnsNotificationTopicHints.getIdFn = getOnsNotificationTopicId

	exportObjectStorageBucketHints.getIdFn = getObjectStorageBucketId
	exportObjectStorageObjectHints.getIdFn = getObjectStorageObjectId
	exportObjectStorageObjectHints.requireResourceRefresh = true
	exportObjectStorageObjectLifecyclePolicyHints.getIdFn = getObjectStorageObjectLifecyclePolicyId
	exportObjectStoragePreauthenticatedRequestHints.getIdFn = getObjectStorageObjectPreauthenticatedRequestId
	exportObjectStoragePreauthenticatedRequestHints.processDiscoveredResourcesFn = processObjectStoragePreauthenticatedRequest
	exportObjectStorageReplicationPolicyHints.getIdFn = getObjectStorageReplicationPolicyId
	exportObjectStorageReplicationPolicyHints.processDiscoveredResourcesFn = processObjectStorageReplicationPolicy

	exportStreamingStreamHints.processDiscoveredResourcesFn = processStreamingStream

	exportContainerengineNodePoolHints.processDiscoveredResourcesFn = processContainerengineNodePool

	exportNosqlIndexHints.getIdFn = getNosqlIndexId
	exportNosqlIndexHints.processDiscoveredResourcesFn = processNosqlIndex

	exportFileStorageMountTargetHints.requireResourceRefresh = true

	exportBudgetAlertRuleHints.getIdFn = getBudgetAlertRuleId

	exportDatacatalogDataAssetHints.getIdFn = getDatacatalogDataAssetId
	exportDatacatalogConnectionHints.getIdFn = getDatacatalogConnectionId
	exportIdentityApiKeyHints.getIdFn = getIdentityApiKeyId

	exportIdentityAuthTokenHints.getIdFn = getIdentityAuthTokenId

	exportIdentityCustomerSecretKeyHints.getIdFn = getIdentityCustomerSecretKeyId

	exportIdentityIdpGroupMappingHints.getIdFn = getIdentityIdpGroupMappingId

	exportIdentitySmtpCredentialHints.getIdFn = getIdentitySmtpCredentialId

	exportIdentitySwiftPasswordHints.getIdFn = getIdentitySwiftPasswordId

	exportKmsKeyHints.getIdFn = getKmsKeyId
	exportKmsKeyHints.processDiscoveredResourcesFn = processKmsKey

	exportKmsKeyVersionHints.getIdFn = getKmsKeyVersionId

	exportDnsRrsetHints.getIdFn = getDnsRrsetId
	exportDnsRrsetHints.findResourcesOverrideFn = findDnsRrset
	exportDnsRrsetHints.processDiscoveredResourcesFn = processDnsRrset

	exportMysqlMysqlBackupHints.requireResourceRefresh = true
	exportMysqlMysqlBackupHints.processDiscoveredResourcesFn = filterMysqlBackups
	exportMysqlMysqlDbSystemHints.processDiscoveredResourcesFn = processMysqlDbSystem
}

func processDnsRrset(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {

	for _, record := range resources {
		// Populate config file from compositeId
		record.compartmentId = record.parent.compartmentId
		domain, rtype, zoneNameOrId, _, _, err := parseRrsetCompositeId(record.id)
		if err == nil {
			record.sourceAttributes["domain"] = domain
			record.sourceAttributes["rtype"] = rtype
			record.sourceAttributes["zone_name_or_id"] = zoneNameOrId
		}
	}
	return resources, nil
}

func findDnsRrset(ctx *resourceDiscoveryContext, tfMeta *TerraformResourceAssociation, parent *OCIResource, resourceGraph *TerraformResourceGraph) (resources []*OCIResource, err error) {
	// Rrset is singular datasource only
	// and need to use GetZoneRecordsRequest to list all records
	zoneId := parent.id
	request := oci_dns.GetZoneRecordsRequest{}
	request.ZoneNameOrId = &zoneId
	response, err := ctx.clients.dnsClient().GetZoneRecords(context.Background(), request)

	if err != nil {
		return resources, err
	}

	for _, record := range response.Items {
		recordResource := resourcesMap[tfMeta.resourceClass]
		d := recordResource.TestResourceData()
		zoneId := parent.id
		domain := record.Domain
		rtype := record.Rtype
		d.SetId(getRrsetCompositeId(*domain, *rtype, zoneId))
		if err := recordResource.Read(d, ctx.clients); err != nil {
			ctx.errorList = append(ctx.errorList, &ResourceDiscoveryError{tfMeta.resourceClass, parent.terraformName, err, resourceGraph})
			continue
		}
		resource := &OCIResource{
			compartmentId:    parent.compartmentId,
			sourceAttributes: convertResourceDataToMap(recordResource.Schema, d),
			rawResource:      record,
			TerraformResource: TerraformResource{
				id:             d.Id(),
				terraformClass: tfMeta.resourceClass,
				terraformName:  fmt.Sprintf("%s_%s", parent.parent.terraformName, *record.RecordHash),
			},
			getHclStringFn: getHclStringFromGenericMap,
			parent:         parent,
		}
		resources = append(resources, resource)
	}

	return resources, err
}

func getDnsRrsetId(resource *OCIResource) (string, error) {
	domain, ok := resource.sourceAttributes["domain"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find domain for DnsRrset")
	}
	rtype, ok := resource.sourceAttributes["rtype"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find rtype for DnsRrset")
	}
	zoneId := resource.parent.id
	return getRrsetCompositeId(domain, rtype, zoneId), nil
}

func getDatacatalogDataAssetId(resource *OCIResource) (string, error) {
	dataAssetKey, ok := resource.sourceAttributes["key"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find data_asset_key for Data Asset")
	}
	catalogId := resource.parent.id

	return getDataAssetCompositeId(catalogId, dataAssetKey), nil
}

func getDatacatalogConnectionId(resource *OCIResource) (string, error) {
	connectionKey, ok := resource.sourceAttributes["key"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find key for Data Asset Connection")
	}
	dataAssetKey, ok := resource.sourceAttributes["data_asset_key"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find data_asset_key for Data Asset")
	}
	catalogId, ok := resource.parent.sourceAttributes["catalog_id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find catalog_id for Data Asset")
	}

	return getConnectionCompositeId(catalogId, connectionKey, dataAssetKey), nil
}

// Custom functions to alter behavior of resource discovery and resource HCL representation

func getIdentityApiKeyId(resource *OCIResource) (string, error) {
	fingerPrint, ok := resource.sourceAttributes["fingerprint"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find fingerprint for Api Key")
	}
	userId := resource.parent.id

	return getApiKeyCompositeId(fingerPrint, userId), nil
}

func getModelProvenanceId(resource *OCIResource) (string, error) {
	modelId := resource.parent.id

	return getModelProvenanceCompositeId(modelId), nil
}

func getIdentityAuthTokenId(resource *OCIResource) (string, error) {
	authTokenId, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find id for Auth Token")
	}
	userId := resource.parent.id

	return getAuthTokenCompositeId(authTokenId, userId), nil
}

func getIdentityCustomerSecretKeyId(resource *OCIResource) (string, error) {
	id, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find id for Customer Secrest Key")
	}
	userId := resource.parent.id

	return getCustomerSecretKeyCompositeId(id, userId), nil
}

func getIdentityIdpGroupMappingId(resource *OCIResource) (string, error) {
	id, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find id for Customer Secrest Key")
	}
	providerId := resource.parent.id

	return getIdpGroupMappingCompositeId(providerId, id), nil
}

func getIdentitySmtpCredentialId(resource *OCIResource) (string, error) {
	id, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find id for Smtp Credential")
	}
	userId := resource.parent.id

	return getSmtpCredentialCompositeId(id, userId), nil
}

func getIdentitySwiftPasswordId(resource *OCIResource) (string, error) {
	id, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find id for Swift Password")
	}
	userId := resource.parent.id

	return getSwiftPasswordCompositeId(id, userId), nil
}

func getBlockchainOsnId(resource *OCIResource) (string, error) {
	id, ok := resource.sourceAttributes["osn_key"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find id for Blockchain OSN")
	}
	blockchainPlatformId := resource.parent.id

	return getOsnCompositeId(blockchainPlatformId, id), nil
}

func getBlockchainPeerId(resource *OCIResource) (string, error) {
	id, ok := resource.sourceAttributes["peer_key"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find id for Blockchain Peer")
	}
	blockchainPlatformId := resource.parent.id

	return getPeerCompositeId(blockchainPlatformId, id), nil
}

func processContainerengineNodePool(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, nodePool := range resources {
		// subnet_ids and quantity_per_subnet are deprecated and conflict with node_config_details
		if _, exists := nodePool.sourceAttributes["node_config_details"]; exists {
			if _, ok := nodePool.sourceAttributes["subnet_ids"]; ok {
				delete(nodePool.sourceAttributes, "subnet_ids")
			}
			if _, ok := nodePool.sourceAttributes["quantity_per_subnet"]; ok {
				delete(nodePool.sourceAttributes, "quantity_per_subnet")
			}
		}
	}
	return resources, nil
}

func processStreamingStream(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, streamingStream := range resources {
		// compartment_id conflict with stream_pool_id
		if _, exists := streamingStream.sourceAttributes["compartment_id"]; exists {
			if _, ok := streamingStream.sourceAttributes["stream_pool_id"]; ok {
				delete(streamingStream.sourceAttributes, "stream_pool_id")
			}
		}
	}
	return resources, nil
}

func processNosqlIndex(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, index := range resources {
		index.sourceAttributes["table_name_or_id"] = index.parent.id
	}
	return resources, nil
}

func getNosqlIndexId(resource *OCIResource) (string, error) {
	name, ok := resource.sourceAttributes["name"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find name for Index id")
	}
	tableNameOrId := resource.parent.id

	return getIndexCompositeId(name, tableNameOrId), nil
}

func processKmsKey(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		resource.sourceAttributes["management_endpoint"] = resource.parent.sourceAttributes["management_endpoint"].(string)
		var resourceSchema *schema.ResourceData = resource.rawResource.(*schema.ResourceData)
		resource.sourceAttributes["id"] = resourceSchema.Id()
	}
	return resources, nil
}

func getKmsKeyId(resource *OCIResource) (string, error) {
	managementEndpoint, ok := resource.parent.sourceAttributes["management_endpoint"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find management_endpoint for Index id")
	}
	var keyId string
	// observed that Id is not always available in sourceAttributes - refer export_compartment.go->findResourcesGeneric() to visualize below docs
	// resource.sourceAttributes has the id in the cases where getKmsKeyId is called with LIST data source response, because list SetData() sets the Id, but this is only done temporarily to populate compositeID
	// When getKmsKeyId is called for resource, resource.sourceAttributes is not set yet,(so far we used LIST response to get composite Id) but we can get the real ocid after Read because Id was set in the method kms_key_resource.go->readKmsKey()
	switch resource.rawResource.(type) {
	case *schema.ResourceData:
		// 	rawResource from resource read response
		var resourceSchema *schema.ResourceData = resource.rawResource.(*schema.ResourceData)
		keyId = resourceSchema.Id()
	case map[string]interface{}:
		// 	rawResource from LIST data source read response
		var resourceMap map[string]interface{} = resource.rawResource.(map[string]interface{})
		keyId = resourceMap["id"].(string)
	}
	return getCompositeKeyId(managementEndpoint, keyId), nil
}

func getKmsKeyVersionId(resource *OCIResource) (string, error) {
	managementEndpoint, ok := resource.parent.sourceAttributes["management_endpoint"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find management_endpoint for Index id")
	}
	keyId := resource.parent.sourceAttributes["id"].(string)
	keyVersionId := resource.sourceAttributes["key_version_id"].(string)
	return getCompositeKeyVersionId(managementEndpoint, keyId, keyVersionId), nil
}

// Custom functions to alter behavior of resource discovery and resource HCL representation

func getBudgetAlertRuleId(resource *OCIResource) (string, error) {
	alertRuleId, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find alert_rule_id for Alert Rule")
	}
	budgetId := resource.parent.id

	return getAlertRuleCompositeId(alertRuleId, budgetId), nil
}

func processPrivateIps(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	privateIps := []*OCIResource{}

	for _, privateIp := range resources {

		if privateIp.hasFreeformTag(ResourceCreatedByInstancePool) {
			continue
		}

		// OKE will add tagging support, for now we rely on Automatic default tags for tenancies created after December 17, 2019
		if privateIp.hasDefinedTag(OracleTagsCreatedBy, OkeTagValue) {
			continue
		}

		privateIps = append(privateIps, privateIp)
	}

	return privateIps, nil
}

func processInstances(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	for _, instance := range resources {
		// Omit any resources that were launched by an instance pool. Those shouldn't be managed by Terraform as they are created
		// and managed through the instance pool resource instead.
		if instance.hasFreeformTag(ResourceCreatedByInstancePool) {
			continue
		}

		// OKE will add tagging support, for now we rely on Automatic default tags for tenancies created after December 17, 2019
		if instance.hasDefinedTag(OracleTagsCreatedBy, OkeTagValue) {
			continue
		}

		// Ensure the boot volume created by this instance can be referenced elsewhere by adding it to the reference map
		if bootVolumeId, exists := instance.sourceAttributes["boot_volume_id"]; exists {
			if bootVolumeIdStr, ok := bootVolumeId.(string); ok {
				referenceMap[bootVolumeIdStr] = tfHclVersion.getDoubleExpHclString(instance.getTerraformReference(), "boot_volume_id")
			}
		}

		if rawSourceDetailsList, sourceDetailsExist := instance.sourceAttributes["source_details"]; sourceDetailsExist {
			if sourceDetailList, ok := rawSourceDetailsList.([]interface{}); ok && len(sourceDetailList) > 0 {
				if sourceDetails, ok := sourceDetailList[0].(map[string]interface{}); ok {
					if imageId, ok := instance.sourceAttributes["image"].(string); ok {
						sourceDetails["source_id"] = imageId

						// The image OCID may be different if it's in a different tenancy or region, add a variable for users to specify
						imageVarName := fmt.Sprintf("%s_source_image_id", instance.terraformName)
						vars[imageVarName] = fmt.Sprintf("\"%s\"", imageId)
						referenceMap[imageId] = tfHclVersion.getVarHclString(imageVarName)
					}

					// Workaround for service limitation. Service returns 47GB size for boot volume but LaunchInstance can only
					// accept sizes 50GB and above. If such a situation arises, fall back to service default values for boot volume size.
					if bootVolumeSizeInGbs, exists := sourceDetails["boot_volume_size_in_gbs"]; exists {
						bootVolumeSize, err := strconv.ParseInt(bootVolumeSizeInGbs.(string), 10, 64)
						if err != nil {
							return resources, err
						}

						if bootVolumeSize < 50 {
							delete(sourceDetails, "boot_volume_size_in_gbs")
						}
					}
				}
			}
		}

		results = append(results, instance)
	}

	return results, nil
}

func filterSecondaryVnicAttachments(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	for _, attachment := range resources {
		// Filter out any primary vnics, as it's not necessary to create separate TF resources for those.
		datasourceSchema := datasourcesMap["oci_core_vnic"]
		if vnicReadFn := datasourceSchema.Read; vnicReadFn != nil {
			d := datasourceSchema.TestResourceData()
			d.Set("vnic_id", attachment.sourceAttributes["vnic_id"].(string))
			if err := vnicReadFn(d, clients); err != nil {
				return results, err
			}

			if isPrimaryVnic, ok := d.GetOkExists("is_primary"); ok && isPrimaryVnic.(bool) {
				continue
			}
		}
		results = append(results, attachment)
	}

	return results, nil
}

func filterMysqlBackups(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	// Filter out Mysql Backups that are automatically created. We cannot operate on "Automatic" backups.
	for _, backup := range resources {
		sourceDetails, exists := backup.sourceAttributes["creation_type"]

		if exists && sourceDetails.(string) == "AUTOMATIC" {
			continue
		}

		results = append(results, backup)
	}

	return results, nil
}

// TODO: remove this when service fixes source
func processMysqlDbSystem(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, dbSystem := range resources {
		if source, exists := dbSystem.sourceAttributes["source"]; exists {
			if sourceList := source.([]interface{}); len(sourceList) > 0 {
				if sourceMap, ok := sourceList[0].(map[string]interface{}); ok {
					if sourceMap["source_type"].(string) == "NONE" {
						delete(dbSystem.sourceAttributes, "source")
					}
				}
			}
		}
	}

	return resources, nil
}

func filterSourcedBootVolumes(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	// Filter out boot volumes that don't have source details. We cannot create boot volumes unless they have source details.
	for _, bootVolume := range resources {
		sourceDetails, exists := bootVolume.sourceAttributes["source_details"]
		if !exists {
			continue
		}

		if sourceDetailsList, ok := sourceDetails.([]interface{}); !ok || len(sourceDetailsList) == 0 {
			continue
		}

		results = append(results, bootVolume)
	}

	return results, nil
}

func processAvailabilityDomains(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for idx, ad := range resources {
		ad.sourceAttributes["index"] = idx + 1

		adName, ok := ad.sourceAttributes["name"].(string)
		if !ok || adName == "" {
			return resources, fmt.Errorf("[ERROR] availability domain at index '%v' has no name\n", idx)
		}
		referenceMap[adName] = tfHclVersion.getDataSourceHclString(ad.getTerraformReference(), "name")
	}

	return resources, nil
}

func processObjectStorageNamespace(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, ns := range resources {
		namespaceName, ok := ns.sourceAttributes["namespace"].(string)
		if !ok || namespaceName == "" {
			return resources, fmt.Errorf("[ERROR] object storage namespace data source has no name\n")
		}
		referenceMap[namespaceName] = tfHclVersion.getDataSourceHclString(ns.getTerraformReference(), "namespace")
	}

	return resources, nil
}

func getAvailabilityDomainHCLDatasource(builder *strings.Builder, ociRes *OCIResource, varMap map[string]string) error {
	builder.WriteString(fmt.Sprintf("data %s %s {\n", ociRes.terraformClass, ociRes.terraformName))

	builder.WriteString(fmt.Sprintf("compartment_id = %v\n", varMap[ociRes.compartmentId]))

	adIndex, ok := ociRes.sourceAttributes["index"]
	if !ok {
		return fmt.Errorf("[ERROR] no index found for availability domain '%s'", ociRes.getTerraformReference())
	}
	builder.WriteString(fmt.Sprintf("ad_number = \"%v\"\n", adIndex.(int)))
	builder.WriteString("}\n")

	return nil
}

func getObjectStorageNamespaceHCLDatasource(builder *strings.Builder, ociRes *OCIResource, varMap map[string]string) error {
	builder.WriteString(fmt.Sprintf("data %s %s {\n", ociRes.terraformClass, ociRes.terraformName))
	builder.WriteString(fmt.Sprintf("compartment_id = %v\n", varMap[ociRes.compartmentId]))
	builder.WriteString("}\n")

	return nil
}

func filterCustomImages(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}

	// Filter out official images that are predefined by Oracle. We cannot manage such images in Terraform.
	// Official images have a null or empty compartment ID.
	for _, image := range resources {
		compartmentId, exists := image.sourceAttributes["compartment_id"]
		if !exists {
			continue
		}

		if compartmentIdString, ok := compartmentId.(string); !ok || len(compartmentIdString) == 0 {
			continue
		}

		results = append(results, image)
	}

	return results, nil
}

func processVolumeGroups(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	// Replace the volume group's source details volume list with the actual volume list
	// The source details only captures the list of volumes that were known when the group was created.
	// Additional volumes may have been added since and should be part of the source_details that we generate.
	// TODO: This is a shortcoming that should be addressed by the service and/or the Terraform
	for _, group := range resources {
		volumeIdsRaw, exists := group.sourceAttributes["volume_ids"]
		if !exists {
			continue
		}

		if volumeIds, ok := volumeIdsRaw.([]interface{}); ok && len(volumeIds) > 0 {
			sourceDetailsRaw, detailsExist := group.sourceAttributes["source_details"]
			if !detailsExist {
				continue
			}

			sourceDetails := sourceDetailsRaw.([]interface{})[0].(map[string]interface{})
			sourceDetails["volume_ids"] = volumeIds
		}
	}

	return resources, nil
}

func processLoadBalancerBackendSets(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, backendSet := range resources {
		backendSetName := backendSet.sourceAttributes["name"].(string)
		backendSet.id = getBackendSetCompositeId(backendSetName, backendSet.parent.id)
		backendSet.sourceAttributes["load_balancer_id"] = backendSet.parent.id
	}

	return resources, nil
}

func processLoadBalancerBackends(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, backend := range resources {
		backend.id = getBackendCompositeId(backend.sourceAttributes["name"].(string), backend.parent.sourceAttributes["name"].(string), backend.parent.sourceAttributes["load_balancer_id"].(string))
		backend.sourceAttributes["load_balancer_id"] = backend.parent.sourceAttributes["load_balancer_id"].(string)

		// Don't use references to parent resources if they will be omitted from final result
		if !backend.parent.omitFromExport {
			backend.sourceAttributes["backendset_name"] = InterpolationString{
				resourceReference: backend.parent.getTerraformReference(),
				interpolation:     tfHclVersion.getDoubleExpHclString(backend.parent.getTerraformReference(), "name"),
				value:             backend.parent.sourceAttributes["name"].(string),
			}
		} else {
			backend.sourceAttributes["backendset_name"] = backend.parent.sourceAttributes["name"].(string)
		}
	}

	return resources, nil
}

func processLoadBalancerHostnames(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, hostname := range resources {
		hostname.id = getHostnameCompositeId(hostname.parent.id, hostname.sourceAttributes["name"].(string))
		hostname.sourceAttributes["load_balancer_id"] = hostname.parent.id
	}

	return resources, nil
}

func processLoadBalancerPathRouteSets(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, pathRouteSet := range resources {
		pathRouteSet.id = getPathRouteSetCompositeId(pathRouteSet.parent.id, pathRouteSet.sourceAttributes["name"].(string))
		pathRouteSet.sourceAttributes["load_balancer_id"] = pathRouteSet.parent.id
	}

	return resources, nil
}

func processLoadBalancerRuleSets(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, ruleSet := range resources {
		ruleSet.id = getRuleSetCompositeId(ruleSet.parent.id, ruleSet.sourceAttributes["name"].(string))
		ruleSet.sourceAttributes["load_balancer_id"] = ruleSet.parent.id
	}

	return resources, nil
}

func processLoadBalancerCertificates(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, certificate := range resources {
		certificate.id = getCertificateCompositeId(certificate.sourceAttributes["certificate_name"].(string), certificate.parent.id)
		certificate.sourceAttributes["load_balancer_id"] = certificate.parent.id
	}

	return resources, nil
}

func getOnsNotificationTopicId(resource *OCIResource) (string, error) {
	id, ok := resource.sourceAttributes["topic_id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find topic id for ons notification topic")
	}
	return id, nil
}

func getObjectStorageBucketId(resource *OCIResource) (string, error) {
	name, ok := resource.sourceAttributes["name"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find name for bucket id")
	}

	namespace, ok := resource.sourceAttributes["namespace"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find namespace for bucket id")
	}

	return getBucketCompositeId(name, namespace), nil
}

func getObjectStorageObjectId(resource *OCIResource) (string, error) {
	name, ok := resource.sourceAttributes["name"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find name for object id")
	}

	bucket, ok := resource.parent.sourceAttributes["name"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find bucket for object id")
	}

	namespace, ok := resource.parent.sourceAttributes["namespace"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find namespace for object id")
	}

	return getObjectCompositeId(bucket, namespace, name), nil
}

func getObjectStorageObjectLifecyclePolicyId(resource *OCIResource) (string, error) {
	bucket, ok := resource.sourceAttributes["bucket"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find bucket for object Lifecycle Policy id")
	}

	namespace, ok := resource.sourceAttributes["namespace"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find namespace for object Lifecycle Policy id")
	}

	return getObjectLifecyclePolicyCompositeId(bucket, namespace), nil
}

func getObjectStorageObjectPreauthenticatedRequestId(resource *OCIResource) (string, error) {
	parId, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find parId for PreauthenticatedRequest id")
	}

	bucket, ok := resource.parent.sourceAttributes["name"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find bucket for PreauthenticatedRequest id")
	}

	namespace, ok := resource.parent.sourceAttributes["namespace"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find namespace for PreauthenticatedRequest id")
	}

	return getPreauthenticatedRequestCompositeId(bucket, namespace, parId), nil
}

func processObjectStoragePreauthenticatedRequest(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		resource.sourceAttributes["bucket"] = resource.parent.sourceAttributes["name"].(string)
		resource.sourceAttributes["namespace"] = resource.parent.sourceAttributes["namespace"].(string)

		// Check if time is already in RFC3339Nano format
		timeExpires, err := time.Parse(time.RFC3339Nano, resource.sourceAttributes["time_expires"].(string))
		if err != nil {
			// parse time using format in time.String()
			timeExpires, err = time.Parse("2006-01-02 15:04:05.999999999 -0700 MST", resource.sourceAttributes["time_expires"].(string))
			if err != nil {
				return resources, err
			}
			// Format to RFC3339Nano
			resource.sourceAttributes["time_expires"] = timeExpires.Format(time.RFC3339Nano)
		}

	}
	return resources, nil
}

func processAutonomousDatabaseSource(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		if resource.sourceAttributes["is_refreshable_clone"] == true {
			resource.sourceAttributes["source"] = "CLONE_TO_REFRESHABLE"
		}
	}
	return resources, nil
}

func getObjectStorageReplicationPolicyId(resource *OCIResource) (string, error) {
	replicationId, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find replicationId for replication id")
	}

	bucket, ok := resource.parent.sourceAttributes["name"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find bucket for replication id")
	}

	namespace, ok := resource.parent.sourceAttributes["namespace"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find namespace for replication id")
	}

	return getReplicationPolicyCompositeId(bucket, namespace, replicationId), nil
}

func processObjectStorageReplicationPolicy(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		resource.sourceAttributes["bucket"] = resource.parent.sourceAttributes["name"].(string)
		resource.sourceAttributes["namespace"] = resource.parent.sourceAttributes["namespace"].(string)
	}
	return resources, nil
}

func findIdentityTags(ctx *resourceDiscoveryContext, tfMeta *TerraformResourceAssociation, parent *OCIResource, resourceGraph *TerraformResourceGraph) ([]*OCIResource, error) {
	// List on Tags does not return validator, and resource Read requires tagNamespaceId
	// which is also not returned in Summary response. Tags also do not have composite id in state.
	// Getting tags using ListTagsRequest and the calling tagResource.Read
	tagNamespaceId := parent.id
	request := oci_identity.ListTagsRequest{}

	request.TagNamespaceId = &tagNamespaceId

	request.RequestMetadata.RetryPolicy = getRetryPolicy(true, "identity")
	results := []*OCIResource{}

	response, err := ctx.clients.identityClient().ListTags(context.Background(), request)
	if err != nil {
		return results, err
	}

	request.Page = response.OpcNextPage

	for request.Page != nil {
		listResponse, err := ctx.clients.identityClient().ListTags(context.Background(), request)
		if err != nil {
			return results, err
		}

		response.Items = append(response.Items, listResponse.Items...)
		request.Page = listResponse.OpcNextPage
	}

	for _, tag := range response.Items {
		tagResource := resourcesMap[tfMeta.resourceClass]

		d := tagResource.TestResourceData()
		d.SetId(getIdentityTagCompositeId(*tag.Name, parent.id))

		if err := tagResource.Read(d, ctx.clients); err != nil {
			ctx.errorList = append(ctx.errorList, &ResourceDiscoveryError{tfMeta.resourceClass, parent.terraformName, err, resourceGraph})
			continue
		}

		resource := &OCIResource{
			compartmentId:    parent.compartmentId,
			sourceAttributes: convertResourceDataToMap(tagResource.Schema, d),
			rawResource:      tag,
			TerraformResource: TerraformResource{
				id:             d.Id(),
				terraformClass: tfMeta.resourceClass,
			},
			getHclStringFn: getHclStringFromGenericMap,
			parent:         parent,
		}

		if resource.terraformName, err = generateTerraformNameFromResource(resource.sourceAttributes, tagResource.Schema); err != nil {
			resource.terraformName = fmt.Sprintf("%s_%s", parent.parent.terraformName, *tag.Name)
		}

		results = append(results, resource)
	}

	return results, nil

}

func processTagDefinitions(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		resource.sourceAttributes["tag_namespace_id"] = resource.parent.id
		resource.importId = fmt.Sprintf("tagNamespaces/%s/tags/%s", resource.parent.id, resource.sourceAttributes["name"].(string))
	}
	return resources, nil
}

func findLoadBalancerListeners(ctx *resourceDiscoveryContext, tfMeta *TerraformResourceAssociation, parent *OCIResource, resourceGraph *TerraformResourceGraph) ([]*OCIResource, error) {
	loadBalancerId := parent.sourceAttributes["load_balancer_id"].(string)
	backendSetName := parent.sourceAttributes["name"].(string)

	request := oci_load_balancer.GetLoadBalancerRequest{}
	request.LoadBalancerId = &loadBalancerId
	request.RequestMetadata.RetryPolicy = getRetryPolicy(true, "load_balancer")

	response, err := ctx.clients.loadBalancerClient().GetLoadBalancer(context.Background(), request)
	if err != nil {
		return nil, err
	}

	listenerResource := resourcesMap[tfMeta.resourceClass]

	results := []*OCIResource{}
	for listenerName, listener := range response.LoadBalancer.Listeners {
		if *listener.DefaultBackendSetName != backendSetName {
			continue
		}

		d := listenerResource.TestResourceData()
		d.SetId(getListenerCompositeId(listenerName, loadBalancerId))

		// This calls into the listener resource's Read fn which has the unfortunate implementation of
		// calling GetLoadBalancer and looping through the listeners to find the expected one. So this entire method
		// may require O(n^^2) time. However, the benefits of having Read populate the ResourceData struct is better than duplicating it here.
		if err := listenerResource.Read(d, ctx.clients); err != nil {
			// add error to the errorList and continue discovering rest of the resources
			ctx.errorList = append(ctx.errorList, &ResourceDiscoveryError{tfMeta.resourceClass, parent.terraformName, err, resourceGraph})
			continue
		}

		resource := &OCIResource{
			compartmentId:    parent.compartmentId,
			sourceAttributes: convertResourceDataToMap(listenerResource.Schema, d),
			rawResource:      listener,
			TerraformResource: TerraformResource{
				id:             d.Id(),
				terraformClass: tfMeta.resourceClass,
				terraformName:  fmt.Sprintf("%s_%s", parent.parent.terraformName, listenerName),
			},
			getHclStringFn: getHclStringFromGenericMap,
			parent:         parent,
		}

		if !parent.omitFromExport {
			resource.sourceAttributes["default_backend_set_name"] = InterpolationString{
				resourceReference: parent.getTerraformReference(),
				interpolation:     tfHclVersion.getDoubleExpHclString(parent.getTerraformReference(), "name"),
				value:             parent.sourceAttributes["name"].(string),
			}
		} else {
			resource.sourceAttributes["default_backend_set_name"] = parent.sourceAttributes["name"].(string)
		}
		results = append(results, resource)
	}

	return results, nil
}

func processNetworkSecurityGroupRules(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	for _, resource := range resources {
		resource.sourceAttributes["network_security_group_id"] = resource.parent.id
	}
	return resources, nil
}

func filterPrimaryDbHomes(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	// No need to filter if db homes are in vm cluster
	if len(resources) > 0 && resources[0].parent.terraformClass == "oci_database_vm_cluster" {
		return resources, nil
	}
	results := []*OCIResource{}
	for _, resource := range resources {
		// Only return dbHome resources that don't match the db home ID of the db system resource.
		if dbHomes, ok := resource.parent.sourceAttributes["db_home"].([]interface{}); ok && len(dbHomes) > 0 {
			if primaryDbHome, ok := dbHomes[0].(map[string]interface{}); ok {
				if primaryDbHomeId, ok := primaryDbHome["id"]; ok && primaryDbHomeId.(string) != resource.id {
					results = append(results, resource)
				}
			}
		}
		// Fix db version to remove the PSU date from versions with 18+ major version
		if dbVersion, ok := resource.sourceAttributes["db_version"].(string); ok {
			resource.sourceAttributes["db_version"] = getValidDbVersion(dbVersion)
		}
	}
	return results, nil
}

func filterPrimaryDatabases(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	results := []*OCIResource{}
	for _, resource := range resources {
		// Only return database resources that don't match the database ID of the dbHome resource.
		if databases, ok := resource.parent.sourceAttributes["database"].([]interface{}); ok && len(databases) > 0 {
			if primaryDatabase, ok := databases[0].(map[string]interface{}); ok {
				if primaryDatabaseId, ok := primaryDatabase["id"]; ok && primaryDatabaseId.(string) != resource.id {
					results = append(results, resource)
				}
			}
		}
	}
	return results, nil
}

func processIdentityAuthenticationPolicies(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	// Add composite id as the resource's import ID
	for _, resource := range resources {
		resource.importId = getAuthenticationPolicyCompositeId(resource.compartmentId)
		resource.id = resource.importId
	}
	return resources, nil
}

func processDefaultSecurityLists(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	// Default security lists need to be handled as default resources
	for _, resource := range resources {
		if resource.id == resource.parent.sourceAttributes["default_security_list_id"].(string) {
			resource.sourceAttributes["manage_default_resource_id"] = resource.id
			resource.TerraformResource.terraformClass = "oci_core_default_security_list"

			// Don't use references to parent resources if they will be omitted from final result
			if !resource.parent.omitFromExport {
				resource.TerraformResource.terraformReferenceIdString = fmt.Sprintf("%s.%s", resource.parent.getTerraformReference(), "default_security_list_id")
			}
		}
	}
	return resources, nil
}

func processDefaultRouteTables(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	// Default route tables need to be handled as default resources
	for _, resource := range resources {
		if resource.id == resource.parent.sourceAttributes["default_route_table_id"].(string) {
			resource.sourceAttributes["manage_default_resource_id"] = resource.id
			resource.TerraformResource.terraformClass = "oci_core_default_route_table"

			// Don't use references to parent resources if they will be omitted from final result
			if !resource.parent.omitFromExport {
				resource.TerraformResource.terraformReferenceIdString = fmt.Sprintf("%s.%s", resource.parent.getTerraformReference(), "default_route_table_id")
			}
		}
	}
	return resources, nil
}

func processDefaultDhcpOptions(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	// Default dhcp options need to be handled as default resources
	for _, resource := range resources {
		if resource.id == resource.parent.sourceAttributes["default_dhcp_options_id"].(string) {
			resource.sourceAttributes["manage_default_resource_id"] = resource.id
			resource.TerraformResource.terraformClass = "oci_core_default_dhcp_options"

			// Don't use references to parent resources if they will be omitted from final result
			if !resource.parent.omitFromExport {
				resource.TerraformResource.terraformReferenceIdString = fmt.Sprintf("%s.%s", resource.parent.getTerraformReference(), "default_dhcp_options_id")
			}
		}
	}
	return resources, nil
}

func getCoreNetworkSecurityGroupSecurityRuleId(resource *OCIResource) (string, error) {
	networkSecurityGroupId := resource.parent.id
	securityRuleId, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find id for CoreNetworkSecurityGroupSecurityRule composite id")
	}

	return getNetworkSecurityGroupSecurityRuleCompositeId(networkSecurityGroupId, securityRuleId), nil
}

func getDatabaseVmClusterNetworkId(resource *OCIResource) (string, error) {
	exadataInfrastructureId, ok := resource.sourceAttributes["exadata_infrastructure_id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find exadata_infrastructure_id for VmCluster network id")
	}

	id, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find id for VmCluster network id")
	}

	return getVmClusterNetworkCompositeId(exadataInfrastructureId, id), nil
}

func processDbSystems(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	// Fix db version to remove the PSU date from versions with 18+ major version
	for _, resource := range resources {
		if dbHomes, ok := resource.sourceAttributes["db_home"].([]interface{}); ok {
			if dbHome, ok := dbHomes[0].(map[string]interface{}); ok {
				if dbVersion, ok := dbHome["db_version"].(string); ok {
					dbHome["db_version"] = getValidDbVersion(dbVersion)
				}
			}
		}
	}
	return resources, nil
}

func processDatabases(clients *OracleClients, resources []*OCIResource) ([]*OCIResource, error) {
	// Fix database db version to remove the PSU date from versions with 18+ major version
	for _, resource := range resources {
		if databases, ok := resource.sourceAttributes["database"].([]interface{}); ok {
			if database, ok := databases[0].(map[string]interface{}); ok {
				if dbVersion, ok := database["db_version"].(string); ok {
					database["db_version"] = getValidDbVersion(dbVersion)
				}
			}
		}
	}
	return resources, nil
}

func getValidDbVersion(dbVersion string) string {
	/*
		For 11.2.0.4, 12.1.0.2 and 12.2.0.1, the PSU is added as the 5th digit. So when the customer specifies either of these,
		service will be returning 11.2.0.4.xxxxxx where the last part is the PSU version.
		For 18.0.0.0 and 19.0.0.0 onwards, the second digit specifies the PSU version and the fifth digit specifies the date for that PSU.
		(The PSU-date pair change hand in hand)
		* For pre 18 versions, service returns 5th digit in response and 5 digit version is valid for create
		* For 18+ versions, service will return PSU date but only 4 digit version is valid for create.
		* Resource discovery will keep only 4 digits in config and dbVersionDiffSuppress will handle the diff
	*/
	parts := strings.Split(dbVersion, ".")
	if strings.Compare(parts[0], "18") == 1 {
		return strings.Join(parts[0:4], ".")
	}
	return dbVersion
}

func getLogId(resource *OCIResource) (string, error) {
	logId, ok := resource.sourceAttributes["id"].(string)
	if !ok {
		return "", fmt.Errorf("[ERROR] unable to find log_id for Log")
	}
	logGroupId := resource.parent.id
	return getLogCompositeId(logGroupId, logId), nil
}
